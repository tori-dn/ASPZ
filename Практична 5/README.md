# Завдання 3.1
Умова: Реалізуйте фрагмент програми з подвійним звільненням пам’яті, який не завжди викликає помилку при виконанні.

### Код завдання:
```
#include <stdio.h>
#include <stdlib.h>

void maybe_free_twice(int *p, int flag) {
    free(p);
    if (flag) {
        free(p);
    }
}

int main() {
    int *ptr = malloc(sizeof(int));
    *ptr = 100;

    maybe_free_twice(ptr, 1); 

    printf("Program has ended.\n");
    return 0;
}
```

---

### Пояснення програми:
У цбому завдані помилка виникає через подвійне звільнення пам’яті `(double free)`. Це одна з критичних помилок керування динамічною пам’яттю в C. Вона трапляється, коли програма викликає `free(p)` для одного й того ж показника більше одного разу. У першому виклику `free(p)` виділена пам’ять повертається системі, і p стає "висячим" `(dangling pointer)` — тобто вже не вказує на дійсну область пам’яті. Повторний виклик `free(p)` працює з уже звільненою адресою, що порушує внутрішню структуру керування пам’яттю і може призвести до аварійного завершення програми або навіть бути використаним зловмисником для атак (наприклад, heap poisoning).

Виправити цю помилку можна кількома способами. Найнадійніший — одразу після виклику `free(p)` присвоїти показнику значення `NULL`. Це робить подальший виклик `free(p)` безпечним, оскільки free `(NULL)` за стандартом є допустимим і не викликає жодних дій. Також важливо уникати подвійного звільнення в логіці програми — наприклад, переконатися, що пам’ять звільняється лише в одному місці або встановити умовну перевірку перед `free().`

### Результат роботи
![task](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%205/task.png)


