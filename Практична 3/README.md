# Завдання 3.1
Умова: Запустіть Docker-контейнер і поекспериментуйте з максимальним лімітом ресурсів відкритих файлів. 
Для цього виконайте команди у вказаному порядку:
```
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3001
$ ulimit -n 2000
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
```
Як наступне вправу, повторіть перераховані команди з root-правами.

### Виконання:
``
docker run -it --rm --ulimit nofile=4096:4096 ubuntu bash
``

```
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3001
$ ulimit -n 2000
$ ulimit -n
$ ulimit -aS | grep "open files"
$ ulimit -aH | grep "open files"
$ ulimit -n 3000
```

### З root-правами:

```
docker run -it --rm --privileged ubuntu bash
apt update && apt install -y procps

```

### Пояснення програми:
Це завдання спрямоване на дослідження обмеження системного ресурсу — максимальної кількості відкритих файлів `(ulimit -n)` у Docker-контейнері. За допомогою команд `ulimit` користувач перевіряє поточні значення м’якого `(soft)` і жорсткого `(hard)` лімітів, а також намагається змінити їх, щоб зрозуміти, як працюють ці обмеження. Це дозволяє краще зрозуміти механізми контролю доступу до ресурсів у Linux-системах і те, як вони впливають на процеси, зокрема в середовищі Docker, як під звичайним користувачем, так і з `root`-правами.

---

### Результат роботи
![task1](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%201/task1.png)
![task1](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%201/task1_2.png)

---

# Завдання 3.2
Умова: У Docker-контейнері встановіть утиліту `perf(1)`. Поекспериментуйте з досягненням процесом встановленого ліміту.

### Спочатку встановимо `perf(1)` за допомогою команди:
`` sudo apt update && sudo apt install -y linux-tools-common linux-tools-generic linux-tools-$(uname -r)``

---

### Скрипт:
```
#!/bin/bash

counter=0
while true; do
  sleep 60 & 
  counter=$((counter + 1))
  echo "Created $counter processes"
done

```
---

### Пояснення програми:
У цьому завданні демонструється, як обмеження на кількість процесів (через `ulimit -u`) впливають на роботу програм усередині Docker-контейнера. Скрипт створює у нескінченному циклі нові фонові процеси `(sleep 60 &)`, що поступово наближає систему до досягнення ліміту процесів. Коли ліміт вичерпується, нові процеси не можуть бути створені, і система починає виводити повідомлення про помилку. Це наочно показує, як адміністратор може контролювати використання ресурсів у контейнеризованих середовищах.

Команда `ps aux | grep task2.sh` використовується для пошуку процесів, пов’язаних із виконанням скрипта `task2.sh`. Вона дозволяє перевірити, чи справді скрипт запущено, скільки екземплярів створено, і чи продовжує він працювати — це зручно для діагностики та контролю процесів під час експерименту.

---

### Результат роботи
![task2](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%202/task22.png)
![task2](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%202/task2_2.png)

---

# Завдання 3.3
Умова: Напишіть програму, що імітує кидання шестигранного кубика. Імітуйте кидки, результати записуйте у файл, для якого попередньо встановлено обмеження на його максимальний розмір (max file size). Коректно обробіть ситуацію перевищення ліміту.


---

### Код програми:
```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *f = fopen("dice_results.txt", "w");
    if (!f) {
        perror("Cannot open file");
        return 1;
    }

    srand(time(NULL));

    for (int i = 0; i < 1000000; i++) {
        int roll = (rand() % 6) + 1;

        if (fprintf(f, "%d\n", roll) < 0) {
            fprintf(stderr, "Error writing to file: %s\n", strerror(errno));
            break;
        }
    }

    if (fclose(f) != 0) {
        perror("Error closing file");
        return 1;
    }

    return 0;
}

```

---

### Пояснення програми:
Цей код генерує мільйон випадкових чисел від 1 до 6, і записує кожне число у файл `dice_result.txt` Для генерації випадкових чисел використовується функція `rand()`, а файл відкривається для запису в текстовому режимі. Програма контролює можливі помилки при відкритті файлу, записі та закритті, щоб уникнути втрати даних чи аварійного завершення. Це корисно для тестування навантаження на файлову систему або демонстрації обмежень розміру файлу через системні ліміти.

---

### Результат роботи
![task3](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%203/task3.png)

---

# Завдання 3.4
Умова: Напишіть програму, що імітує лотерею, вибираючи 7 різних цілих чисел у діапазоні від 1 до 49 і ще 6 з 36. Встановіть обмеження на час ЦП (max CPU time) і генеруйте результати вибору чисел (7 із 49, 6 із 36). Обробіть ситуацію, коли ліміт ресурсу вичерпано.


---

### Код програми:
```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <signal.h>

void handler(int sig) {
    printf("CPU time limit exceeded!\n");
    exit(1);
}

int main() {
    signal(SIGXCPU, handler);
    srand(time(NULL));

    printf("7 numbers from 1 to 49: ");
    for (int i = 0; i < 7; i++) {
        printf("%d ", (rand() % 49) + 1);
    }
    printf("\n6 numbers from 1 to 36: ");
    for (int i = 0; i < 6; i++) {
        printf("%d ", (rand() % 36) + 1);
    }
    printf("\n");

    while (1);  

    return 0;
}
```

---

### Пояснення програми:
Ця програма генерує дві послідовності випадкових чисел: 7 чисел у діапазоні від 1 до 49 і 6 чисел у діапазоні від 1 до 36, і виводить їх на екран. Вона встановлює обробник сигналу SIGXCPU, який спрацьовує у разі перевищення обмеження часу використання процесора (CPU time limit), після чого програма виводить повідомлення про перевищення ліміту і завершується. Для демонстрації споживання CPU часу у кінці використовується нескінченний цикл, що дозволяє протестувати встановлене обмеження ресурсів системи.

---

### Результат роботи
![task4](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%204/task4.png)

---

# Завдання 3.5
Умова: Напишіть програму для копіювання одного іменованого файлу в інший. Імена файлів передаються у вигляді аргументів.

Програма має:
- перевіряти, чи передано два аргументи, інакше виводити "Program need two arguments";
- перевіряти доступність першого файлу для читання, інакше виводити "Cannot open file .... for reading";
- перевіряти доступність другого файлу для запису, інакше виводити "Cannot open file .... for writing";
- обробляти ситуацію перевищення обмеження на розмір файлу.


---

### Код програми:
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    FILE *in = fopen("input.txt", "r");
    FILE *out = fopen("output.txt", "w");

    if (!in) {
        perror("Cannot open input.txt");
        return 1;
    }
    if (!out) {
        perror("Cannot open output.txt");
        fclose(in);
        return 1;
    }

    int num, count = 0;
    double sum = 0.0;

    while (fscanf(in, "%d", &num) == 1) {
        sum += num;
        count++;
    }

    if (count > 0) {
        double average = sum / count;
        fprintf(out, "Average score: %.2f\n", average);
    } else {
        fprintf(out, "No numbers found in input file.\n");
    }

    fclose(in);
    fclose(out);
    printf("File copied successfully!")

    return 0;
}
```
input.txt
``
Hello
World
!!!
``

---

### Пояснення програми:
Ця програма відкриває вхідний файл input.txt для читання чисел та вихідний файл output.txt для запису результату. Вона послідовно зчитує всі цілі числа з вхідного файлу, підраховує їхню суму та кількість, а потім обчислює середнє значення (середній бал). Отримане середнє записується у вихідний файл з точністю до двох знаків після коми. Якщо вхідний файл порожній або не містить чисел, у вихідний файл буде записано відповідне повідомлення. Це дозволяє автоматизувати обробку оцінок та легко отримати їх статистику.

---

### Результат роботи
![task5](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%205/task5.png)

---

# Завдання 3.6
Умова: 

---

### Код програми:
```
#include <stdio.h>

void recurse(int depth) {
    char buffer[1024];  
    printf("Depth: %d\n", depth);
    recurse(depth + 1);
}

int main() {
    recurse(1);
    return 0;
}

```
---

### Пояснення програми:
Ця програма демонструє рекурсивний виклик функції `recurse`, яка на кожному рівні створює великий локальний масив `buffer` розміром 1024 байти, тим самим активно споживаючи стек. Функція виводить поточну глибину рекурсії і викликає саму себе з аргументом, збільшеним на 1. Оскільки немає умови зупинки, рекурсія триває безмежно, поки не вичерпається стек, що призведе до аварійного завершення програми (segmentation fault) через переповнення стека. Цей код ілюструє, як надмірне використання пам’яті в стеку може спричинити падіння програми.

---

### Результат роботи
![task6](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%206/task6.png)

---

# Завдання по варіантам
Умова: Встановити ліміт на використання CPU (ulimit -t) і запустити нескінченний цикл.

---

### Скрипт:
```
#!/bin/bash
while true; do
  :
done

```
---

### Пояснення програми:
Це завдання демонструє, як працює обмеження на час процесора `(CPU time)`, встановлене за допомогою `ulimit -t`. Скрипт запускає нескінченний цикл `(while true; do :; done)`, який постійно навантажує процесор, виконуючи порожню команду. Якщо перед запуском цього скрипта встановити обмеження, наприклад `ulimit -t 2`, процес буде автоматично завершено після використання 2 секунд процесорного часу. Для вимірювання фактичного часу виконання скрипта використовувалась команда `time`, яка показує, скільки часу процес реально працював `(user, system, real)`, що дозволяє перевірити, чи спрацювало обмеження та як швидко процес завершився після його досягнення.

---

### Результат роботи
![task](https://github.com/tori-dn/ASPZ/blob/main/%D0%9F%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%BD%D0%B0%203/%D0%97%D0%B0%D0%B2%D0%B4%D0%B0%D0%BD%D0%BD%D1%8F%20%D0%BF%D0%BE%20%D0%B2%D0%B0%D1%80%D1%96%D0%B0%D0%BD%D1%82%D0%B0%D1%85/task7.png)

---

